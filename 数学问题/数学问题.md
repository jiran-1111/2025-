## 数学问题





## 模板



### 判断素数

```c++
// 判断x是否为质数
bool is_prime(int x) {
    if (x <= 1) return false;  // 1及以下不是质数
    if (x <= 3) return true;   // 2、3是质数
    if (x % 2 == 0) return false;  // 偶数（除2外）不是质数
    // 只检查奇数因子，范围[3, sqrt(x)]
    for (int i = 3;i<=sqrt(x); i += 2) {  // i*i <= x 等价于 i <= x/i（避免溢出）
        if (x % i == 0) return false;
    }
    return true;
}
```

### 最大公约数

```c++
// 辗转相除法求a和b的最大公约数
int gcd(int a, int b) {
    // 当b为0时，a即为最大公约数
    return b == 0 ? a : gcd(b, a % b);
}
```

- 核心是 “辗转相除”：`gcd(a,b) = gcd(b,a%b)`；
- 递归终止条件：`b=0` 时返回 `a`。

### 求约数

```c++
#include<bits/stdc++.h>
using namespace std;
int n;
long long a;
vector<int> res;
unordered_set<int> a_res;
int main(){
    cin>>n;
    while(n--){
        cin>>a;
        res.clear();
        a_res.clear();
        for(long long i=1;i<=sqrt(a);i++){
            if(a%i==0){
                res.push_back(i);
                res.push_back(a/i);
            }
        }
        sort(res.begin(),res.end());
        for(auto &p:res){
            if(a_res.count(p)==0){
                cout<<p<<" ";
                a_res.insert(p);//忘了去重了 一定要记住！！！
            }
            
        }
        cout<<endl;
    }
    
    return 0;
}
```



### 约数个数

把所求的数的拆解成质因数相乘的形式，然后把质因数的系数进行+1后相乘即为约数个数

```c++
#include<bits/stdc++.h>

using namespace std;
const int mod=1e9+7;
int n;
long long a;
unordered_map<int, int> r;//注意这种开数组不型，开map可以大大节约空间 使用r[i]来计算即可

int main(){
    long long ans=1;//注意答案设longlong 
    cin>>n;
    
    while(n--){
        cin>>a;
        for(int i=2;i<=a/i;i++){
            while(a%i==0){
                r[i]++;//i的系数+1
                a=a/i;
                
            }
        }
        if(a>1) r[a]++;
        
     
    }
    for(auto &p:r){
        int zhishu=p.first;
        int xishu =p.second;
        
        ans=ans*(xishu+1)%mod;
        
            
    }
    cout<<ans<<endl;
    
    return 0;
}
```

### 约数之和

一个数拆成质因数分解相乘的形式，每个因子的和为（p^0 + p^1+ p^2+….) 然后再把每个质因子的和相乘

```c++
#include<bits/stdc++.h>
using namespace std;
int T;
int t;
const int mod=1e9+7;
long long ans=1;
unordered_map<int,int> r;
int main(){
    cin>>T;
    while(T--){
        cin>>t;
        for(long long i=2;i<=sqrt(t);i++){
            while(t%i==0){
                r[i]++;
                t/=i;
            }
        }
        if(t>1) r[t]++;
    }
    //重点重点！！！！！！
    for(auto &p:r){
        int index=p.second;
        int zhiyinzi=p.first;

        long long t=1;

        
        while(index--){
            t=(t*zhiyinzi+1)%mod;
           
        }
        
        ans=ans*t%mod;
        
    }
    cout<<ans<<endl;
    return 0;
}
```



### 快速幂

用二进制的办法

比如：

13 的二进制是 `1101`。
 这就表示：

13=8+4+113 = 8 + 4 + 113=8+4+1

所以：



我们只要能快速算出 31,32,34,38,...3^1, 3^2, 3^4, 3^8, ...31,32,34,38,...，就能拼出结果了。



```c++
int quick_pow(int a,int b,int p){
    int res=1;
    while(b){
        if(b&1){
            //该位是1
            res=(LL) res*a%p;
        }
        b>>=1;//权重*2
        a=a*a;
    }
    return res;
}
```

