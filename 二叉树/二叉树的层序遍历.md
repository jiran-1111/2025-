## 二叉树的宽度遍历

## 模板

```c++
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> q;
        vector<int> res;
        if(root==nullptr) return res;//一定要记得判断空
        q.push(root);

        while(!q.empty()){
            int n=q.size();//该层节点的个数
            
            for(int i=0;i<n;i++){
                //遍历这一层的节点
                auto tmp=q.front();
                q.pop();
                //这一步进行处理
                if(i==n-1) res.push_back(tmp->val);
				
                //一定要先判断是否空 否则会报错
                if(tmp->left!=nullptr) q.push(tmp->left);
                if(tmp->right!=nullptr) q.push(tmp->right);

            }

        }
        return res;
    }
```



runtime error: member access within null pointer这个报错应该大概率是没有处理空指针，或者空指针进栈了



## 题目

### 108. 将有序数组转换为二叉搜索树

[108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)

```c++
class Solution {
public:
    TreeNode* dfs(vector<int>& nums,int left,int right){
        if(left==right) return nullptr;
        int m=(left+right)/2;
        return new TreeNode(nums[m],dfs(nums,left,m),dfs(nums,m+1,right));
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return dfs(nums,0,nums.size());

        //把数组正中间的数看做根节点
        //得到左右两个小数组
    }
};
```



另一道类似的题

为什么他是中等

### 109. 有序链表转换成二叉搜索树

[109. 有序链表转换二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/description/)

给定一个单链表的头节点  `head` ，其中的元素 **按升序排序** ，将其转换为 平衡 二叉搜索树。

```c++
class Solution {
public:
    TreeNode* sortedListToBST(ListNode* head) {
        vector<int> nums;
        int k=0;
        ListNode* flag=head;
        while(flag!=nullptr){
            nums.push_back(flag->val);
            flag=flag->next;
        }
        return sorted(nums);

    }
    
    TreeNode* dfs(vector<int>& nums,int left,int right){
        if(left==right) return nullptr;
        int m=(left+right)/2;
        return new TreeNode(nums[m],dfs(nums,left,m),dfs(nums,m+1,right));
    }
    TreeNode* sorted(vector<int>& nums) {
        return dfs(nums,0,nums.size());

        //把数组正中间的数看做根节点
        //得到左右两个小数组
    }
};
```





### 98. 验证二叉搜索树

[98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **严格小于** 当前节点的数。
- 节点的右子树只包含 **严格大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。



这个题很有意思，几乎是108那个题的反面

只需要把**二叉搜索树转化为有序数组即可** 然后看有没有逆序即可



**刚开始掉到陷阱里，不能只看左孩子和右孩子，要左子树所有节点都小于根才行。**

```c++
class Solution {
public:
    vector<int> vec;
    void traversal(TreeNode* root){
        if(root==NULL) return;
        traversal(root->left);
        vec.push_back(root->val);//将二叉搜索树转化为有序数组 左中右
        traversal(root->right);
    }

    bool isValidBST(TreeNode* root) {
        travresal(root);
        for(int i=1;i<vec.size();i++){
            if(vec[i]<=vec[i-1]) return false;
        }
        return true;
    }
};
```





### 230. 二叉搜索树中第k小的元素

[230. 二叉搜索树中第 K 小的元素 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）。



更加类似的题   把二叉搜索树转换成有序数组

```c++
class Solution {
public:
    vector<int> vec;
    void dfs(TreeNode* cur){
        if(cur==nullptr) return;
        dfs(cur->left);
        vec.push_back(cur->val);//把二叉搜索树转换成有序数组
        dfs(cur->right);

    }
    int kthSmallest(TreeNode* root, int k) {
        //把二叉搜索树转换成有序数组 然后再排序
        dfs(root);
        return vec[k-1];
    }
};
```







### 199. 二叉树的右视图

[199. 二叉树的右视图 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

正经用栈实现的层序遍历 一定要好好背



```c++
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> q;
        vector<int> res;
        if(root==nullptr) return res;
        q.push(root);

        while(!q.empty()){
            int n=q.size();//该层节点的个数
            
            for(int i=0;i<n;i++){
                //遍历这一层的节点
                auto tmp=q.front();
                q.pop();
                if(i==n-1) res.push_back(tmp->val);

                if(tmp->left!=nullptr) q.push(tmp->left);
                if(tmp->right!=nullptr) q.push(tmp->right);

            }

        }
        return res;
    }
};
```

