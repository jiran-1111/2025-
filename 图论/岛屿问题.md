## 万用模板
岛屿问题就是给你一个二维矩阵，用0,1分别代表海洋和岛屿，然后对其性质进行计算。通常使用dfs的方法进行遍历，把一片岛屿一次性遍历完成，然后对已经遍历后的岛屿进行标记。
```
class Solution {
public:
    int dfs(vector<vector<char>>& grid, int i, int j) {
        // 递归中，写出结束条件，例如
        if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == 0) {
            return 0;
        }
        // 定义两个数组，用于访问当前节点的上下左右的四个节点，进行递归调用
        int di[4] = {-1,0,1,0};
        int dj[4] = {0,1,0,-1};
        // 遍历临近四个节点，进行递归调用
        for (int index = 0; index < 4; ++index) {
            int next_i = di[index];
            int next_j = dj[index];
            // 此处根据题目具体需求进行操作，这里只是给出一个示例
            df(grid, next_i,next_j);
        }

        return xxx;
    } 

    int numIslands(vector<vector<char>>& grid) {
        // 遍历每个节点，每个节点都调用 dfs，从 dfs 中获取想要的结果
        for (int i = 0; i < grid.size(); ++i) {
            for (int j = 0; j < grid[0].size(); ++j) {
                df(grid, i, j); 
            }
        }
        return xxx;
    }
};

作者：你可别卷了
链接：https://leetcode.cn/problems/number-of-islands/solutions/1379125/by-zhang-xiao-lang-2-zdke/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
### 200. 岛屿数量   
https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-100-liked

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

示例 1：
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1

一篇比较好的题解：
https://leetcode.cn/problems/number-of-islands/solutions/1379125/by-zhang-xiao-lang-2-zdke/?envType=study-plan-v2&envId=top-100-liked
岛屿问题可以都用dfs来解决 注意模板
```
class Solution {
private:
    int di[4]={-1,0,1,0};
    int dj[4]={0,1,0,-1};

public:
    int df(vector<vector<char>>& grid,int i,int j){
        if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]=='0'){
            return 0;
        }//超出界限或者是海洋就返回
        grid[i][j]='0';//已经访问
        for(int index=0;index<4;++index){//深度优先遍历
            int next_i=i+di[index];
            int next_j=j+dj[index];
            df(grid,next_i,next_j);//一直找到海岛的边间 然后把他们的值都设为0 
        }
        return 1;
    }
    int numIslands(vector<vector<char>>& grid) {
        //深度优先搜索 插满旗子后 答案+1
        //遍历每个节点 每个节点都调用dfs
        int num=0;
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[0].size();j++){
                num+=df(grid,i,j);
            }
        }
        return num;

    }
};
```
