## 该章节题目序号：

**200 695 1020 1254 130**

## 万用模板

岛屿问题就是给你一个二维矩阵，用0,1分别代表海洋和岛屿，然后对其性质进行计算。通常使用dfs的方法进行遍历，把一片岛屿一次性遍历完成，然后对已经遍历后的岛屿进行标记。



一篇比较好的题解：
https://leetcode.cn/problems/number-of-islands/solutions/1379125/by-zhang-xiao-lang-2-zdke/?envType=study-plan-v2&envId=top-100-liked

```c++
class Solution {
public:
    int dfs(vector<vector<char>>& grid, int i, int j) {
        // 递归中，写出结束条件，例如
        if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] == 0) {
            return 0;
        }
        // 定义两个数组，用于访问当前节点的上下左右的四个节点，进行递归调用
        int di[4] = {-1,0,1,0};
        int dj[4] = {0,1,0,-1};
        // 遍历临近四个节点，进行递归调用
        for (int index = 0; index < 4; ++index) {
            int next_i = di[index];
            int next_j = dj[index];
            // 此处根据题目具体需求进行操作，这里只是给出一个示例
            df(grid, next_i,next_j);
        }

        return xxx;
    } 

    int numIslands(vector<vector<char>>& grid) {
        // 遍历每个节点，每个节点都调用 dfs，从 dfs 中获取想要的结果
        for (int i = 0; i < grid.size(); ++i) {
            for (int j = 0; j < grid[0].size(); ++j) {
                df(grid, i, j); 
            }
        }
        return xxx;
    }
};

```

## 题目

### 200. 岛屿数量

[200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

示例 1：
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1



岛屿问题可以都用dfs来解决 注意模板

```c++
class Solution {
private:
    int di[4]={-1,0,1,0};
    int dj[4]={0,1,0,-1};

public:
    int df(vector<vector<char>>& grid,int i,int j){
        if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]=='0'){
            return 0;
        }//超出界限或者是海洋就返回
        grid[i][j]='0';//已经访问
        for(int index=0;index<4;++index){//深度优先遍历
            int next_i=i+di[index];
            int next_j=j+dj[index];
            df(grid,next_i,next_j);//一直找到海岛的边间 然后把他们的值都设为0 
        }
        return 1;
    }
    int numIslands(vector<vector<char>>& grid) {
        //深度优先搜索 插满旗子后 答案+1
        //遍历每个节点 每个节点都调用dfs
        int num=0;
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[0].size();j++){
                num+=df(grid,i,j);
            }
        }
        return num;

    }
};
```



### 695. 岛屿最大面积

[695. 岛屿的最大面积 - 力扣（LeetCode）](https://leetcode.cn/problems/max-area-of-island/description/)

给你一个大小为 `m x n` 的二进制矩阵 `grid` 。

**岛屿** 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在 **水平或者竖直的四个方向上** 相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

岛屿的面积是岛上值为 `1` 的单元格的数目。

计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 `0` 。

```c++
class Solution {
private:
    int dx[4]={-1,0,1,0};
    int dy[4]={0,1,0,-1};

public:
    int dfs(vector<vector<int>>& grid,int i,int j){
        if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]==0){
            return 0;
        }
        grid[i][j]=0;
        int result=1;
        for(int k=0;k<4;k++){
            int next_x=i+dx[k];
            int next_y=j+dy[k];
            result+=dfs(grid,next_x,next_y);//每次向下深入的时候都加上result 不要想着用参数带下去
        }
        return result;
        
    }
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int max_s=0;
        
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[0].size();j++){
                max_s=max(max_s,dfs(grid,i,j));
            }
        }
        return max_s;
    }
};
```



### 1020. 飞地的数量

[1020. 飞地的数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-enclaves/description/)

给你一个大小为 `m x n` 的二进制矩阵 `grid` ，其中 `0` 表示一个海洋单元格、`1` 表示一个陆地单元格。

一次 **移动** 是指从一个陆地单元格走到另一个相邻（**上、下、左、右**）的陆地单元格或跨过 `grid` 的边界。

返回网格中 **无法** 在任意次数的移动中离开网格边界的陆地单元格的数量。



看题差点没明白啥意思

题目问的是：

> 有哪些陆地格子 **永远无法通过移动离开网格边界**？
>  换句话说，如果从这个陆地出发，无论怎么走，都只能在网格内部活动，永远出不了边界。

你需要 **统计这些被“困住”的陆地格子的数量**。

先遍历外面的一圈，然后进行dfs，把能出去的陆地都标记为0，剩下的陆地块数量即为所求

```c++
class Solution {
private:
    int dx[4]={0,-1,0,1};
    int dy[4]={1,0,-1,0};
public:
    void dfs(vector<vector<int>>& grid,int i,int j){
        if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]==0){
            return ;
        }
        grid[i][j]=0;
        for(int index=0;index<4;index++){
            int x=i+dx[index];
            int y=j+dy[index];
            dfs(grid,x,y);
        }
    }
    int numEnclaves(vector<vector<int>>& grid) {
      for(int i=0;i<grid.size();i++){
        for(int j=0;j<grid[0].size();j++){
            if(i==0||i==grid.size()-1||j==0||j==grid[0].size()-1){
                //第一行和最后一行
                dfs(grid,i,j);
            }
            
        }
      } 
      int ans=0;
      for(int i=1;i<grid.size()-1;i++){
        for(int j=1;j<grid[0].size()-1;j++){
            if(grid[i][j]==1) ans++;
        }
      } 
      return ans;
    }
};
```





### 1254. 统计封闭岛屿的树目

[1254. 统计封闭岛屿的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-closed-islands/description/)

二维矩阵 `grid` 由 `0` （土地）和 `1` （水）组成。岛是由最大的4个方向连通的 `0` 组成的群，封闭岛是一个 `完全` 由1包围（左、上、右、下）的岛。

请返回 *封闭岛屿* 的数目。



**岛屿数量和飞地数量两道题目的拼接操作**

先通过遍历外围的陆地，把连接外围的陆地都访问为水，然后再计算陆地的数量即可



```c++
class Solution {
private:
    int di[4]={-1,0,1,0};
    int dj[4]={0,1,0,-1};
public:
    int df(vector<vector<int>>& grid,int i,int j){
        if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]==1){
            return 0;
        }//超出界限或者是海洋就返回
        grid[i][j]=1;//已经访问
        for(int index=0;index<4;++index){//深度优先遍历
            int next_i=i+di[index];
            int next_j=j+dj[index];
            df(grid,next_i,next_j);//一直找到海岛的边间 然后把他们的值都设为0 
        }
        return 1;
    }
    void dfs_clean(vector<vector<int>>& grid,int i,int j){
        if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]==1){
            return ;
        }
        grid[i][j]=1;
        for(int index=0;index<4;index++){
            int x=i+di[index];
            int y=j+dj[index];
            dfs_clean(grid,x,y);
        }
    }
    int closedIsland(vector<vector<int>>& grid) {
        //把与外界连接的陆地都变成水 然后再计算陆地面积即可
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[0].size();j++){
                if(i==0||i==grid.size()-1||j==0||j==grid[0].size()-1){
                //第一行和最后一行
                    dfs_clean(grid,i,j);
                }
            
            }
        }
       
        //深度优先搜索 插满旗子后 答案+1
        //遍历每个节点 每个节点都调用dfs
        int num=0;
        for(int i=0;i<grid.size();i++){
            for(int j=0;j<grid[0].size();j++){
                num+=df(grid,i,j);
            }
        }
        return num;
    }
};

```



### 130. 被围绕的区域

[130. 被围绕的区域 - 力扣（LeetCode）](https://leetcode.cn/problems/surrounded-regions/description/)

给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` 组成，**捕获** 所有 **被围绕的区域**：

- **连接：**一个单元格与水平或垂直方向上相邻的单元格连接。
- **区域：连接所有** `'O'` 的单元格来形成一个区域。
- **围绕：**如果您可以用 `'X'` 单元格 **连接这个区域**，并且区域中没有任何单元格位于 `board` 边缘，则该区域被 `'X'` 单元格围绕。

通过 **原地** 将输入矩阵中的所有 `'O'` 替换为 `'X'` 来 **捕获被围绕的区域**。你不需要返回任何值。





**注意：**

小细节 除了dfs的范围 还要**排除掉已经标记的位置**，否则会陷入死循环 一直遍历自己然后stack overflow报错

***如果出现爆栈 第一反应检查范围 第二检查是不是已经访问的没有标注陷入死循环***

```c++
class Solution {
private:
    int dx[4]={0,1,0,-1};
    int dy[4]={1,0,-1,0};
public:
    //从边缘开始计算与边缘o连通o的都为N 其他都画为x
    void dfs(vector<vector<char>>& grid,int i,int j){
        if(i<0||i>grid.size()-1||j<0||j>grid[0].size()-1||grid[i][j]!='O'){
            //这里注意范围 也要注意 要排除掉已经标记的N 否则会一直遍历自己，然后会爆栈 陷入死循环
            return;
        }
        grid[i][j]='N';
        for(int k=0;k<4;k++){
            int x=i+dx[k];
            int y=j+dy[k];
            dfs(grid,x,y);
        }
    }
    void solve(vector<vector<char>>& board) {
        for(int i=0;i<board.size();i++){
            for(int j=0;j<board[0].size();j++){
                if(i==0||i==board.size()-1||j==0||j==board[0].size()-1){
                   if(board[i][j]=='O'){
                    dfs(board,i,j);
                   } 
                }
            }
        }

        //最后遍历一下 是N的变为O 是O和X的变为X
       
        for(int i=0;i<board.size();i++){
            for(int j=0;j<board[0].size();j++){
                if(board[i][j]=='N'){
                    board[i][j]='O';
                }
                else board[i][j]='X';
            }
        }


    }
};
```

