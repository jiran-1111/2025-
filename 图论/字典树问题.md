# trie树问题

字典树 包括前缀树 trie树等等
序号：208 211 648

## 模板

```c++
struct TrieNode {
    TrieNode* children[26];
    int count;     // 记录以此为结尾的单词数量
    int prefix;    // 记录以此为前缀的单词数量

    TrieNode() : count(0), prefix(0) {
        memset(children, 0, sizeof(children));
    }
};

class Trie {
public:
    TrieNode* root;

    Trie() {
        root = new TrieNode();
    }

    // 插入单词
    void insert(const string& word) {
        TrieNode* node = root;
        for (char c : word) {
            int idx = c - 'a';
            if (!node->children[idx])
                node->children[idx] = new TrieNode();
            node = node->children[idx];
            node->prefix++;
        }
        node->count++;
    }

    // 查询是否存在这个单词
    bool search(const string& word) {
        TrieNode* node = root;
        for (char c : word) {
            int idx = c - 'a';
            if (!node->children[idx]) return false;
            node = node->children[idx];
        }
        return node->count > 0;
    }

    // 查询是否存在以prefix开头的单词
    bool startsWith(const string& prefix) {
        TrieNode* node = root;
        for (char c : prefix) {
            int idx = c - 'a';
            if (!node->children[idx]) return false;
            node = node->children[idx];
        }
        return true;
    }

    // 查询以prefix开头的单词数量
    int countPrefix(const string& prefix) {
        TrieNode* node = root;
        for (char c : prefix) {
            int idx = c - 'a';
            if (!node->children[idx]) return 0;
            node = node->children[idx];
        }
        return node->prefix;
    }

    // 删除一个单词（可选）
    bool remove(const string& word) {
        return _remove(root, word, 0);
    }

private:
    bool _remove(TrieNode* node, const string& word, int depth) {
        if (!node) return false;
        if (depth == word.size()) {
            if (node->count == 0) return false;
            node->count--;
            return true;
        }
        int idx = word[depth] - 'a';
        if (_remove(node->children[idx], word, depth + 1)) {
            node->children[idx]->prefix--;
            // 可加回收节点逻辑
            return true;
        }
        return false;
    }
};
```





## 题目

### 208. 实现Trie前缀树

[208. 实现 Trie (前缀树) - 力扣（LeetCode）](https://leetcode.cn/problems/implement-trie-prefix-tree/description/?envType=study-plan-v2&envId=top-100-liked)

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

比较应试的做法 测试集比较小的情况

```c++
class Trie {
    unordered_set<string> words;
public:
    Trie() {
        //初始化前缀树
        
    }
    
    void insert(string word) {
        //插入字符串word
        words.insert(word);
    }
    
    bool search(string word) {
        //word是否在前缀树中
        return words.count(word)>0;
    }
    
    bool startsWith(string prefix) {
        //prefix是某个前缀
        for(const auto& word:words){
            if(word.rfind(prefix,0)==0) return true;
        }
        return false;
    }
};
```



**正经做法**

```c++
class TrieNode{
public:
    unordered_map<char,TrieNode*> children;//键表示一个字符 然后指针指向子节点
    bool isEnd;//该节点是否是叶子节点
    TrieNode(){//类的构造函数，用于初始化节点：清空子节点哈希表isEnd = false：初始化时将isEnd设为false，表示新节点默认不是字符串的结尾
        children.clear();
        isEnd = false;
    }
};
class Trie {
private:
    TrieNode* root;
public:
    Trie() {
        root = new TrieNode;//创建 否则野指针
    }
    
    void insert(string word) {
        TrieNode* cur = root;
        for(int i=0;i<word.size();i++){
            //当前字符的所有值是否都在哈希表中 没有则插入
            if(cur->children.count(word[i])==0){
                cur->children[word[i]]=new TrieNode();
            }
            cur=cur->children[word[i]];
        }
        cur->isEnd = true;
    }
    
    bool search(string word) {
        TrieNode* cur=root;
        for(int i=0;i<word.size();i++){
            if(cur->children.count(word[i])==0){
                return false;
            }
            cur=cur->children[word[i]];
        }
        return cur->isEnd;
    }
    
    bool startsWith(string prefix) {
        TrieNode* cur=root;
        for(int i=0;i<prefix.size();i++){
            if(cur->children.count(prefix[i])==0){
                return false;
            }
            cur=cur->children[prefix[i]];
        }
        return true;
    }
};
```









### 211.添加与搜索单词

[211. 添加与搜索单词 - 数据结构设计 - 力扣（LeetCode）](https://leetcode.cn/problems/design-add-and-search-words-data-structure/description/)

请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。

实现词典类 `WordDictionary` ：

- `WordDictionary()` 初始化词典对象
- `void addWord(word)` 将 `word` 添加到数据结构中，之后可以对它进行匹配
- `bool search(word)` 如果数据结构中存在字符串与 `word` 匹配，则返回 `true` ；否则，返回 `false` 。`word` 中可能包含一些 `'.'` ，每个 `.` 都可以表示任何一个字母



为什么只是上一题的稍微变形也会写错

1、遍历一个map还是set都需要用迭代器 没法访问

2、往子节点进行伸展需要cur=cur->children[word[i]]

这里的children相当于好多个pair的数组,pair的second存的是指针，我们需要遍历访问子节点的是指针



```c++
class TrieNode{
public:
    unordered_map<char,TrieNode*> children;
    bool isend;
    TrieNode(){
        isend=false;
    }
};

class WordDictionary {
    TrieNode* root;
public:
    WordDictionary() {
        root = new TrieNode;
    }
    
    void addWord(string word) {
        TrieNode* cur=root;
        for(int i=0;i<word.size();i++){
            if(cur->children.count(word[i])==0){
                //插入
                cur->children[word[i]]= new TrieNode;
            }
            cur=cur->children[word[i]];
        }
        cur->isend=true;
        
    }
    
    bool new_search(string word,TrieNode* cur){//从这个cur开始能否匹配word
        TrieNode* curr=cur;
        //这里原来也写错了 不能一上来就if (curr->isend) return true; 这行不能直接放在开头，否则会提前返回，导致 "pad" 和 "p.." 这类情况错误。
        for(int i=0;i<word.size();i++){
            if(word[i]=='.'){
                //如果是点
                string new_str=word.substr(i+1);
                for(auto& p:curr->children){//遍历所有子节点
                    //这里原来写错了 要用迭代器进行遍历 
                    if(new_search(new_str,p.second)) return true;
                    
                }
                return false;
            }
            else if(curr->children.count(word[i])==0){
                return false;
            }
            curr=curr->children[word[i]];
            //curr=curr->children; 这行不对，应该用 curr=curr->children[word[i]]。
        }
        return curr->isend;
    }
    bool search(string word) {
        
        return new_search(word,root);
    }
};

```



### 648. 单词替换

[648. 单词替换 - 力扣（LeetCode）](https://leetcode.cn/problems/replace-words/description/)

在英语中，我们有一个叫做 **词根**(root) 的概念，可以词根 **后面** 添加其他一些词组成另一个较长的单词——我们称这个词为 **衍生词** (**derivative**)。例如，词根 `help`，跟随着 **继承**词 `"ful"`，可以形成新的单词 `"helpful"`。

现在，给定一个由许多 **词根** 组成的词典 `dictionary` 和一个用空格分隔单词形成的句子 `sentence`。你需要将句子中的所有 **衍生词** 用 **词根** 替换掉。如果 **衍生词** 有许多可以形成它的 **词根**，则用 **最短** 的 **词根** 替换它。

你需要输出替换之后的句子。





#### 弱智思路



```c++
class Solution {
public:
    string new_short(vector<string>& dictionary,string word){
        string sort_word;
        for(auto root:dictionary){
            int n=root.size();
           
            if(root==word.substr(0,n)){
                
                return root;
            }
        }
        return word;
    }
    static bool cmp(const string &a,const string &b){//c++11后必须写成静态函数
        return a.size()<b.size();
    }

    string replaceWords(vector<string>& dictionary, string sentence) {
        
        sort(dictionary.begin(), dictionary.end(), cmp);
        string tmp;
        string ans="";
        int l=0;
        for(int i=0;i<sentence.size();i++){
            if(sentence[i]==' '||i==sentence.size()-1){
                
                tmp = sentence.substr(l, i - l + (i == sentence.size() - 1 ? 1 : 0));
                //cout<<tmp<<endl;//分割成单词
                l=i+1;

                ans+=new_short(dictionary,tmp);
                if(i!=sentence.size()-1) ans+=" ";
            }

        }
        return ans;
    }
};
```



#### 高效思路

trie树

使用**stringstream**进行输入单词的识别 比substr要不容易错

每次识别一次就把上面的prefix进行+=   这样匹配完成后就可以直接把结果输出了，但确实没有直接输出前缀方便



```c++
class Solution {
public:
    struct TrieNode{
        unordered_map<char,TrieNode*> children;
        int isend;
        TrieNode(){
            isend=false;
        }
    };
    string replaceWords(vector<string>& dictionary, string sentence) {
        //1、把前缀插入trie树
        TrieNode* root=new TrieNode;
        TrieNode* cur;
        vector<string> res;
        for(auto r_word:dictionary){
            //遍历每个单词 进行插入
            cur=root;
            for(int i=0;i<r_word.size();i++){
                if(cur->children.count(r_word[i])==0){
                    //插入
                    cur->children[r_word[i]]=new TrieNode;
                }
                cur=cur->children[r_word[i]];
            }
            cur->isend=true;
        }

        //2、每个单词依次找前缀
        stringstream ss(sentence);
        string word;
        
        while(ss>>word){
            cur=root;
            string prefix;
            bool flag=true;
            for(int i=0;i<word.size();i++){
                if(cur->children.count(word[i])==0){
                    //没有匹配
                    break;
                    
                }
                prefix+=word[i];
                cur=cur->children[word[i]];
                if(cur->isend){
                    flag=false;
                    res.push_back(prefix);
                    break;
                }
                
            }
            if(flag) res.push_back(word);//推入原单词
        }

        //3、拼接结果
        string ans;
        for(int i=0;i<res.size();i++){
            ans += res[i];
            if(i != res.size()-1) ans += " ";
        }
        return ans;
    }
};
```

